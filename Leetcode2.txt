Singly linked list merging

/**
 * Definition for singly-linked list.
 * public class ListNode {
 *     int val;
 *     ListNode next;
 *     ListNode() {}
 *     ListNode(int val) { this.val = val; }
 *     ListNode(int val, ListNode next) { this.val = val; this.next = next; }
 * }
 */
class Solution {
    public ListNode mergeTwoLists(ListNode list1, ListNode list2) {
         // Head node to start the merged list
        ListNode head = new ListNode(0);
        ListNode current = head;

        // While both lists have nodes
        while (list1 != null && list2 != null) {

            if (list1.val <= list2.val) {
                current.next = list1;   // attach l1 node
                list1 = list1.next;        // move l1 forward
            } else {
                current.next = list2;   // attach l2 node
                list2 = list2.next;        // move l2 forward
            }

            current = current.next;  // move merged list forward
        }

        // Attach the remaining list (if any)
        if (list1 != null) {
            current.next = list1;
        } else {
            current.next = list2;
        }

        // The real head is next to dummy
        return head.next;
    }
        
    
}

remove duplicates and total number of unique elements in list using two pointers

i.

class Solution {
    public int removeDuplicates(int[] nums) {
        if (nums.length == 0) {
            return 0;
        }

        int index = 1; // position to place next unique number

        for (int i = 1; i < nums.length; i++) {

            if (nums[i] != nums[i - 1]) {
                nums[index] = nums[i];
                index++;
            }
        }

        return index;
    }

Another version ii.

for (int i = 0; i < nums.length - 1; i++) {
    if (nums[i] != nums[i + 1]) {
        nums[index++] = nums[i];
    }
}
nums[index++] = nums[nums.length - 1];
        

}


Remove elements using two pointers

class Solution {
    public int removeElement(int[] nums, int val) {
        
        int index = 0; // position to place valid elements

        for (int i = 0; i < nums.length; i++) {
            if (nums[i] != val) {
                nums[index] = nums[i];
                index++;
            }
        }

        return index;

    }
}


Find the Index of the first occuracne in the string

class Solution {
    public int strStr(String haystack, String needle) {
        if (needle.length() == 0) {
            return 0;
        }

        for (int i = 0; i <= haystack.length() - needle.length(); i++) {

            int j = 0;

            while (j < needle.length() &&
                   haystack.charAt(i + j) == needle.charAt(j)) {
                j++;
            }

            if (j == needle.length()) {
                return i;
            }
        }

        return -1;
    }
}

