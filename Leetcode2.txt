Singly linked list merging two sorted linked lists:

/**
 * Definition for singly-linked list.
 * public class ListNode {
 *     int val;
 *     ListNode next;
 *     ListNode() {}
 *     ListNode(int val) { this.val = val; }
 *     ListNode(int val, ListNode next) { this.val = val; this.next = next; }
 * }
 */

class Solution{
    public ListNode mergeTwoSortedLists(ListNode list1,ListNode list2){

        ListNode dummy = new ListNode(0); 

        ListNode current = dummy; //For traversing ListNode

        while(list1 != null && list2 != null){
            if(list1.val <= list2.val){
                current.next = list1; //Replacing each node overwrites existing nodes
                list1 = list1.next;
            }
            else{
                current.next = list2 //Replacing each node overwrites existing nodes
                list2 = list2.next;

            }
            current = current.next;
        }

        if(list1 ! = null){ //Attaching remaining nodes ListNode
            current.next = list1;
        }
        else{
            current.next = list2;
        }

        return dummy.next; //We are skipping first node which is zero

        
    }
}

remove duplicates and total number of unique elements in list using two pointers

i.

class Solution {
    public int removeDuplicates(int[] nums) {
        if (nums.length == 0) {
            return 0;
        }

        int index = 1; // position to place next unique number

        for (int i = 1; i < nums.length; i++) {

            if (nums[i] != nums[i - 1]) {
                nums[index] = nums[i];
                index++;
            }
        }

        return index;
    }

Another version ii.

for (int i = 0; i < nums.length - 1; i++) {
    if (nums[i] != nums[i + 1]) {
        nums[index++] = nums[i];
    }
}
nums[index++] = nums[nums.length - 1];
        

}


Remove elements using two pointers

class Solution {
    public int removeElement(int[] nums, int val) {
        
        int index = 0; // position to place valid elements

        for (int i = 0; i < nums.length; i++) {
            if (nums[i] != val) {
                nums[index] = nums[i];
                index++;
            }
        }

        return index;

    }
}


Find the Index of the first occuracne in the string

class Solution {
    public int strStr(String haystack, String needle) {
        if (needle.length() == 0) {
            return 0;
        }

        for (int i = 0; i <= haystack.length() - needle.length(); i++) {

            int j = 0;

            while (j < needle.length() &&
                   haystack.charAt(i + j) == needle.charAt(j)) {
                j++;
            }

            if (j == needle.length()) {
                return i;
            }
        }

        return -1;
    }
}

Length of Last Word:


class Solution {
    public int lengthOfLastWord(String s) {

        int count = 0;

        for(int i = s.length() - 1;i >= 0; i--){

            if(s.charAt(i) != ' '){
                count++;
            }
            else if(s.charAt(i) == ' ' && count > 0){
                break;
            }
        }
        return count;

    }
    
}



