For Linked Lists:


Singly linked list merging two sorted linked lists:

/**
 * Definition for singly-linked list.
 * public class ListNode {
 *     int val;
 *     ListNode next;
 *     ListNode() {}
 *     ListNode(int val) { this.val = val; }
 *     ListNode(int val, ListNode next) { this.val = val; this.next = next; }
 * }
 */

class Solution{
    public ListNode mergeTwoLists(ListNode list1,ListNode list2){

        ListNode dummy = new ListNode(0); 

        ListNode current = dummy; //For traversing ListNode

        while(list1 != null && list2 != null){
            if(list1.val <= list2.val){
                current.next = list1; //We are linking existing nodes into a new order
                list1 = list1.next;
            }
            else{
                current.next = list2; //We are linking existing nodes into a new order
                list2 = list2.next;

            }
            current = current.next;
        }

        if(list1 != null){ //Attaching remaining nodes ListNode
            current.next = list1;
        }
        else{
            current.next = list2;
        }

        return dummy.next; //We are skipping first node which is zero

        
    }
}

Remove Duplicates from singly linked lists:

/**
 * Definition for singly-linked list.
 * public class ListNode {
 *     int val;
 *     ListNode next;
 *     ListNode() {}
 *     ListNode(int val) { this.val = val; }
 *     ListNode(int val, ListNode next) { this.val = val; this.next = next; }
 * }
 */
class Solution {
    public ListNode deleteDuplicates(ListNode head) {

        if(head == null){
            return head;
        }

        ListNode current = head;

        while(current.next != null){

            if(current.val == current.next.val){
                current.next = current.next.next;
            }
            else{
                current = current.next;
            }
        }

        return head;
        
    }
}

//Linked List Cycle:

/**
 * Definition for singly-linked list.
 * class ListNode {
 *     int val;
 *     ListNode next;
 *     ListNode(int x) {
 *         val = x;
 *         next = null;
 *     }
 * }
 */
public class Solution {
    public boolean hasCycle(ListNode head) {

        if (head == null) {
            return false;
        }

        ListNode pointer1 = head; // slow
        ListNode pointer2 = head; // fast

        // fast pointer must be able to move 2 steps
        while (pointer2 != null && pointer2.next != null) {

            pointer1 = pointer1.next;           // move 1 step
            pointer2 = pointer2.next.next;      // move 2 steps

            // if both pointers meet → cycle
            if (pointer1 == pointer2) {
                return true;
            }
        }

        // fast reached null → no cycle
        return false;
    }
}

Intersection of Two Linked Lists:

/**
 * Definition for singly-linked list.
 * public class ListNode {
 *     int val;
 *     ListNode next;
 *     ListNode(int x) {
 *         val = x;
 *         next = null;
 *     }
 * }
 */
public class Solution {
    public ListNode getIntersectionNode(ListNode headA, ListNode headB) {

        if(headA == null || headB == null){
            return null;
        }

        ListNode current1 = headA;
        ListNode current2 = headB;
       

        while (current1 != current2){                                

            if(current1 == null){
                current1 = headB;
            } else{
               current1 = current1.next;
            }

            if(current2 == null){
                current2 = headA;
            } else{
                current2 = current2.next;
            }


        }                       
                        
        return current1;         

    }
}


Find the Index of the first occuracne in the string

class Solution {
    public int strStr(String haystack, String needle) {
        if (needle.length() == 0) {
            return 0;
        }

        for (int i = 0; i <= haystack.length() - needle.length(); i++) {

            int j = 0;

            while (j < needle.length() &&
                   haystack.charAt(i + j) == needle.charAt(j)) {
                j++;
            }

            if (j == needle.length()) {
                return i;
            }
        }

        return -1;
    }
}

Length of Last Word:


class Solution {
    public int lengthOfLastWord(String s) {

        int count = 0;

        for(int i = s.length() - 1;i >= 0; i--){

            if(s.charAt(i) != ' '){
                count++;
            }
            else if(s.charAt(i) == ' ' && count > 0){
                break;
            }
        }
        return count;

    }
    
}



